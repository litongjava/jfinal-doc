(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{553:function(s,n,e){"use strict";e.r(n);var a=e(14),t=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"_5-7-数据库事务处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-数据库事务处理"}},[s._v("#")]),s._v(" 5.7 数据库事务处理")]),s._v(" "),n("h3",{attrs:{id:"_1、db-tx-事务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、db-tx-事务"}},[s._v("#")]),s._v(" 1、Db.tx 事务")]),s._v(" "),n("p",[s._v("在 Db 工具类里面，提供了一个系列的 tx(...) 方法支持数据库事务，以下是 Java 8 的 lambda 语法使用示例：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('Db.tx(() -> {\n  Db.update("update t1 set f1 = ?", 123);\n  Db.update("update t2 set f2 = ?", 456);\n  return true;\n});\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("以上代码中的两个 Db.update 数据库操作将开启事务，return true 提交事务，return false 则回滚事务。Db.tx(...) 做事务的好处是控制粒度更细，也即不必抛出异常即可回滚。")]),s._v(" "),n("p",[s._v("Db.tx 方法 默认针对主数据源 进行事务处理，如果希望对其它数据源开启事务，使用 Db.use(configName).tx(...) 即可。此外，Db.tx(...) 还支持指定事务级别：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('Db.tx(Connection.TRANSACTION_SERIALIZABLE, () -> {\n  Db.update(...);\n  new User().setNickName("james").save();\n  return true;\n});\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("以上代码中的 Db.tx(...) 第一个参数传入了事务级别参数  Connection.TRANSACTION_SERIALIZABLE，该方法对于需要灵活控制事务级的场景十分方便实用。")]),s._v(" "),n("p",[s._v("注意：MySql数据库表必须设置为InnoDB引擎时才支持事务，MyISAM并不支持事务。")]),s._v(" "),n("h3",{attrs:{id:"_2、声明式事务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、声明式事务"}},[s._v("#")]),s._v(" 2､声明式事务")]),s._v(" "),n("p",[s._v("ActiveRecord支持声明式事务，声明式事务需要使用ActiveRecordPlugin提供的拦截器来实现，拦截器的配置方法见Interceptor有关章节。以下代码是声明式事务示例：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('// 本例仅为示例, 并未严格考虑账户状态等业务逻辑\n@Before(Tx.class)\npublic void trans_demo() {\n    // 获取转账金额\n    Integer transAmount = getInt("transAmount");\n    // 获取转出账户id\n    Integer fromAccountId = getInt("fromAccountId");\n    // 获取转入账户id\n    Integer toAccountId = getInt("toAccountId");\n    // 转出操作\n    Db.update("update account set cash = cash - ? where id = ?",\n transAmount, fromAccountId);\n    // 转入操作\n    Db.update("update account set cash = cash + ? where id = ?",\n transAmount, toAccountId);\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("p",[s._v("以上代码中，仅声明了一个Tx拦截器即为action添加了事务支持。")]),s._v(" "),n("p",[s._v("当事务拦截器 Tx 配置在 Controller 层，并且希望使用 try catch 对其进行响应控制，在 jfinal 3.6 及更高版本中可以像下面这样使用：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('@Before(Tx.class)\npublic void trans {\n  try {\n    service.justDoIt(...);\n    render("ok.html");\n  } catch (Exception e) {\n    render("error.html");\n    throw e;\n  }\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("如上所示，只需要在 catch 块中直接使用 render(....) 就可以在异常发生时指定响应的模板。最后一定要使用 throw e 将异常向上抛出，处于上层的 Tx 拦截器才能感知异常并回滚事务。（注意：这个功能是 jfinal 3.6 才添加的）")]),s._v(" "),n("p",[s._v("除此之外ActiveRecord还配备了TxByActionKeys、TxByActionKeyRegex、TxByMethods、TxByMethodRegex，分别支持actionKeys、actionKey正则、actionMethods、actionMethod正则声明式事务，以下是示例代码：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('public void configInterceptor(Interceptors me) {\n   me.add(new TxByMethodRegex("(.*save.*|.*update.*)"));\n   me.add(new TxByMethods("save", "update"));\n \n   me.add(new TxByActionKeyRegex("/trans.*"));\n   me.add(new TxByActionKeys("/tx/save", "/tx/update"));\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("上例中的TxByRegex拦截器可通过传入正则表达式对action进行拦截，当actionKey被正则匹配上将开启事务。TxByActionKeys可以对指定的actionKey进行拦截并开启事务，TxByMethods可以对指定的method进行拦截并开启事务。")]),s._v(" "),n("p",[s._v("特别注意：声明式事务默认只针对主数据源进行回滚，如果希望针对 “非主数据源” 进行回滚，需要使用注解进行配置，以下是示例：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('@TxConfig("otherConfigName")\n@Before(Tx.class)\npublic void doIt() {\n   ...\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("以上代码中的 @TxConfig 注解可以配置针对 otherConfigName 进行回滚。Tx 拦截器是通过捕捉到异常以后才回滚事务的，所以上述代码中的 doIt() 方法中如果有 try catch 块捕获到异常，必须再次抛出，才能让 Tx 拦截器感知并回滚事务。")]),s._v(" "),n("h3",{attrs:{id:"_3、使用技巧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、使用技巧"}},[s._v("#")]),s._v(" 3、使用技巧")]),s._v(" "),n("p",[s._v("建议优先使用 Db.tx(...) 做数据库事务，一是该方式可以让事务覆盖的代码量最小，性能会最好。二是该方式可以利用返回值来控制是否回滚事务，而 Tx 拦截器只能通过捕捉到异常来回滚事务。三是 Java 8 的 lambda 语法使其代码也很简洁。")]),s._v(" "),n("p",[s._v("Tx 事务拦截器在捕捉到异常后回滚事务，会再次抛向外抛出异常，所以在使用 Tx 拦截器来做事务处理时，通常需要再额外添加一个 ExceptionInterceptor，放在 Tx 拦截器之前去再次捕捉到 Tx 所抛出的异常，然后在这里做 renderJson/render 之类的动作向客户端展示不同的数据与页面。如果不添加这样的机制，会展示一个统一默认的 500 error 页面，无法满足所有需求。")]),s._v(" "),n("p",[s._v("综上，强烈建议优先使用 Db.tx(...) 做事务处理。")]),s._v(" "),n("h3",{attrs:{id:"_4、事务级别与性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、事务级别与性能"}},[s._v("#")]),s._v(" 4、事务级别与性能")]),s._v(" "),n("p",[s._v("JDBC 默认的事务级别为：Connection.TRANSACTION_READ_COMMITTED。为了避免某些同学的应用场景下对事务级别要求较高，jfinal 的 ActiveRecordPlugin 默认使用的是 Connection.TRANSACTION_REPEATABLE_READ，但这在对某个表存在高并发锁争用时性能会下降，这时可以通过配置事务级别来提升性能：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public void configPlugin(Plugins me) {\n    ActiveRecordPlugin arp = new ActiveRecordPlugin(...);\n    arp.setTransactionLevel(Connection.TRANSACTION_REPEATABLE_READ);\n    me.add(arp);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("有一位同学就碰到了由事务级别引起的性能问题：")]),s._v(" "),n("p",[s._v("http://www.jfinal.com/feedback/4703?p=1#reply_start")])])}),[],!1,null,null,null);n.default=t.exports}}]);