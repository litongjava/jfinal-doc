(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{532:function(t,e,n){"use strict";n.r(e);var r=n(14),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_4-2-interceptor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-interceptor"}},[t._v("#")]),t._v(" 4.2 Interceptor")]),t._v(" "),e("h3",{attrs:{id:"_1、基本用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、基本用法"}},[t._v("#")]),t._v(" 1、基本用法")]),t._v(" "),e("p",[t._v("Interceptor 可以对方法进行拦截，并提供机会在方法的前后添加切面代码，实现 AOP 的核心目标。Interceptor 接口仅仅定义了一个方法 public void intercept(Invocation inv)。以下是简单示例：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public class DemoInterceptor implements Interceptor {\n    public void intercept(Invocation inv) {\n       System.out.println("Before method invoking");\n       inv.invoke();\n       System.out.println("After method invoking");\n    }\n}\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[t._v("以上代码中的 DemoInterceptor 将拦截目标方法，并且在目标方法调用前后向控制台输出文本。inv.invoke() 这一行代码是对目标方法的调用，在这一行代码的前后插入切面代码可以很方便地实现AOP。")]),t._v(" "),e("p",[t._v("注意：必须调用 inv.invoke() 方法，才能将当前调用传递到后续的 Interceptor 与 Action。")]),t._v(" "),e("p",[t._v("常见错误：目前为止仍有很多同学忘了调用 inv.invoke() 方法，造成 controller 中的 action 不会被执行。在此再次强调一次，一定要调用一次 inv.invoke()，除非是刻意不去调用剩下的拦截器与 action，这种情况仍然需要使用 inv.getController().render()/renderJson() 调用一下相关的 render() 方法为客户端响应数据。")]),t._v(" "),e("p",[t._v("Invocation 作为 Interceptor 接口 intercept 方法中的唯一参数，提供了很多便利的方法在拦截器中使用。以下为 Invocation 中的方法：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("方法")]),t._v(" "),e("th",[t._v("描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("void invoke()")]),t._v(" "),e("td",[t._v("传递本次调用，调用剩下的拦截器与目标方法")])]),t._v(" "),e("tr",[e("td",[t._v("Controller getController()")]),t._v(" "),e("td",[t._v("获取 Action 调用的Controller对象（仅用于控制层拦截）")])]),t._v(" "),e("tr",[e("td",[t._v("String getActionKey()")]),t._v(" "),e("td",[t._v("获取 Action 调用的action key值（仅用于控制层拦截）")])]),t._v(" "),e("tr",[e("td",[t._v("String getControllerKey()")]),t._v(" "),e("td",[t._v("获取 Action 调用的Controller key值（仅用于控制层拦截）")])]),t._v(" "),e("tr",[e("td",[t._v("String getViewPath()")]),t._v(" "),e("td",[t._v("获取 Action 调用的视图路径（仅用于控制层拦截）")])]),t._v(" "),e("tr",[e("td",[t._v("<T> getTarget()")]),t._v(" "),e("td",[t._v("获取被拦截方法所属的对象")])]),t._v(" "),e("tr",[e("td",[t._v("Method getMethod()")]),t._v(" "),e("td",[t._v("获取被拦截方法的 Method 对象")])]),t._v(" "),e("tr",[e("td",[t._v("String getMethodName()")]),t._v(" "),e("td",[t._v("获取被拦截方法的方法名")])]),t._v(" "),e("tr",[e("td",[t._v("Object[] agetArgs()")]),t._v(" "),e("td",[t._v("获取被拦截方法的所有参数值")])]),t._v(" "),e("tr",[e("td",[t._v("Object getArg(int)")]),t._v(" "),e("td",[t._v("获取被拦截方法指定序号的参数值")])]),t._v(" "),e("tr",[e("td",[t._v("<T> getReturnValue()")]),t._v(" "),e("td",[t._v("获取被拦截方法的返回值")])]),t._v(" "),e("tr",[e("td",[t._v("void setArg(int)")]),t._v(" "),e("td",[t._v("设置被拦截方法指定序号的参数值")])]),t._v(" "),e("tr",[e("td",[t._v("void setReturnValue(Object)")]),t._v(" "),e("td",[t._v("设置被拦截方法的返回值")])]),t._v(" "),e("tr",[e("td",[t._v("boolean isActionInvocation()")]),t._v(" "),e("td",[t._v("判断是否为 Action 调用，也即是否为控制层拦截")])])])]),t._v(" "),e("p",[t._v("更正一下上面截图中倒数第三行的一处手误：setArg(int) 应该改为 setArg(int, Object)")]),t._v(" "),e("p",[t._v("注意：jfinal 4.9.03 版本将 getControllerKey() 更名为了 getControllerPath()，原方法被保留仍然可用。更名为 getControllerPath() 是为了让多个 Controller 可以共享同一个 controllerPath 值。")]),t._v(" "),e("h3",{attrs:{id:"_2、-全局共享-注意线程安全问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、-全局共享-注意线程安全问题"}},[t._v("#")]),t._v(" 2､ 全局共享，注意线程安全问题")]),t._v(" "),e("p",[t._v("Interceptor 是全局共享的，所以如果要在其中使用属性需要保证其属性是线程安全的，如下代码将是错误的：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public class MyInterceptor implements Interceptor {\n \n   private int value = 123;\n   \n   public void intercept(Invocation inv) {\n       // 多线程将会并发访问 value 值，造成错乱\n       value++;\n       \n       inv.invoke();\n   }\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("p",[t._v("如上代码所示，其中的 value 属性将会被多线程访问到，从而引发线程安全问题。")])])}),[],!1,null,null,null);e.default=v.exports}}]);